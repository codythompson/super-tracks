uses Plasmacore

# DEBUG
$include "Debug/Atlases.rogue"
$include "Debug/DbgObjs.rogue"

$include "IJ.rogue"
$include "TrackGraph.rogue"
$include "TrackTileInfo.rogue"
$include "TrackNode.rogue"
$include "TrackConnection.rogue"
$include "TileDrawer.rogue"
$include "Drawable.rogue"
$include "TileSet.rogue"
$include "GameObj.rogue"
$include "GameState.rogue"
$include "SwitchTapState.rogue"
$include "GameObjMover.rogue"
$include "TileEvents.rogue"
$include "Camera.rogue"
$include "UIObj.rogue"
$include "UISlider.rogue"

Display( "Main" ).screen = MainScreen

class MainScreen : Screen [singleton]
  PROPERTIES
    tileMap:TileMapLayout
    graph = Atlases.parse(Atlases.level_1):TrackGraph
    tileDrawer = BetterTileDrawer(graph, [trackDbl, switchIndicatorDbl])
    tileEventManager:TileEventManager
    gameObjs = GameObj[]
    mover = LinearObjMover()
    camera:Camera
    baseUI = UIObj()

    debugs=Table<<String,String>>()
    debugX = 10
    debugY = 10
    debugSpacing = 20

    pressTarget:UIObj

  METHODS
    method on_start
      tileMap = TileMapLayout(100, 100, XY(100, 100))
      tileEventManager = TileEventManager(tileMap, graph)
      gameObjs.add(minecartObj)
      camera = Camera(tileMap, minecartObj)

      minecartObj.moveTo(2, 6)
      # minecartObj.moveTo(1, 6)
      minecartObj.speed = 0.01
      minecartObj.currentEntrance = TrackConnection.LEFT
      tileEventManager.on(TileEvent.RELEASE,
        function(e:TileEvent)
          if (e.tileInfo.i == 0 and e.tileInfo.j == 0) Display.screen.change_state(GameState(minecartObj, switchIndicatorImages))
        endFunction)

      change_state( GameState(minecartObj, switchIndicatorImages) )

    method on( e:PointerEvent )
      local target = baseUI.getTarget(e.position)
      if (e.type == PointerEvent.PRESS)
        pressTarget = target
        baseUI.handlePressEvent(UIObjPointerEvent(e, target, pressTarget))
      elseIf (e.type == PointerEvent.MOVE)
        baseUI.handleMoveEvent(UIObjPointerEvent(e, target, pressTarget))
      elseIf (e.type == PointerEvent.RELEASE)
        baseUI.handleReleaseEvent(UIObjPointerEvent(e, target, pressTarget))
      endIf

      tileEventManager.handlePointerEvent(e)

    method on_draw
      Display.clear( Color.DARK_GRAY )
      tileMap.draw(tileDrawer.drawFunc)
      # forEach(i in 0..<tileDrawer.graph.tilesWide)
      #   forEach(j in 0..<tileDrawer.graph.tilesHigh)
      #     local tInfo = tileDrawer.graph.calcLayout(i,j)
      #     if (tInfo.activeExit != TrackConnection.NONE)
      #       Box(tileMap.map_to_screen(tInfo.exitIJ()), XY(10,10)).fill(Color.RED)
      #     endIf
      #   endForEach
      # endForEach
      forEach(obj in gameObjs)
        obj.draw(tileMap)
      endForEach

      baseUI.draw

    method after_draw

      forEach (key at i in debugs.keys)
        SystemFont.anchor = Anchor.TOP_RIGHT
        SystemFont.draw("$: $" (key,debugs[key]), XY(debugX,debugY+(i*debugSpacing)))
      endForEach

    method on_resize
      # Called when the Display.size changes
      # trace Display.size
      # debugX = Display.width - debugSpacing

    method on_update
      forEach(obj in gameObjs)
        mover.moveObj(obj, tileDrawer.graph)
      endForEach

    method after_update
      camera.update
endClass
