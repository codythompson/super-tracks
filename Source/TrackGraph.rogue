class TrackGraph
  GLOBAL METHODS
    # TODO: this is big. Refactor this into multiple methods
    method parse( atlas:String )->TrackGraph
      local lines = atlas.split("\n")
      if (lines.count == 0 or lines.count % 4 != 3)
        throw Exception("[Atlases][parse] unexpected number of lines")
      endIf
      if (lines[0].count % 4 != 3)
        throw Exception("[Atlases][parse] unexpected number of characters wide")
      endIf
      # remove the horizontal '-' separators
      local rows = String[][][]()
      local curRow = String[][]()
      forEach(line at i in lines)
        if (i % 4 != 3)
          curRow.add(line.split('|'))
        else
          rows.add(curRow)
          curRow = String[][]()
        endIf
      endForEach
      rows.add(curRow)

      local colsWide = rows[0][0].count
      local rowsTall = rows.count
      local graph = TrackGraph(colsWide, rowsTall)
      forEach(colIndex in 0..<colsWide)
        forEach(rowIndex in 0..<rowsTall)
          local pairs = TrackConnection[]()
          local activeIndex = 0

          local top = rows[rowIndex][0][colIndex]
          local mid = rows[rowIndex][1][colIndex]
          local bot = rows[rowIndex][2][colIndex]

          # TODO, check for one connections
          # TODO, abstract this into something less hard-codey

          #
          # pairs involving left side of this tile
          #
          # LEFT_TOP
          if (top[0] != ' ')
            pairs.add(TrackConnection.LEFT_TOP)
            if (top[0] == '*') activeIndex = pairs.count-1
          endIf
          # LEFT_RIGHT
          if (mid[0] != ' ')
            pairs.add(TrackConnection.LEFT_RIGHT)
            if (mid[0] == '*') activeIndex = pairs.count-1
          endIf
          # LEFT_BOTTOM
          if (bot[0] != ' ')
            pairs.add(TrackConnection.LEFT_BOTTOM)
            if (bot[0] == '*') activeIndex = pairs.count-1
          endIf

          #
          # pairs involving the top side of this tile
          #
          # TOP_BOTTOM
          if (top[1] != ' ')
            pairs.add(TrackConnection.TOP_BOTTOM)
            if (top[1] == '*') activeIndex = pairs.count-1
          endIf
          # TOP_RIGHT
          if (top[2] != ' ')
            pairs.add(TrackConnection.TOP_RIGHT)
            if (top[2] == '*') activeIndex = pairs.count-1
          endIf

          #
          # pairs involving the right side of this tile
          #
          # RIGHT_BOTTOM
          if (bot[2] != ' ')
            pairs.add(TrackConnection.RIGHT_BOTTOM)
            if (bot[2] == '*') activeIndex = pairs.count-1
          endIf

          graph.setNodeAt(colIndex, rowIndex, TrackNode(pairs, activeIndex))
        endForEach
      endForEach

      return graph

  PROPERTIES
    nodes:TrackNode[][]
  METHODS
    method init( tilesWide:Int32, tilesHigh:Int32 )
      nodes = Dim<<TrackNode>>(tilesWide, tilesHigh)

    method tilesWide->Int32
      return nodes.count

    method tilesHigh->Int32
      return nodes[0].count

    method contains( i:Int32, j:Int32 )->Logical
      return i >= 0 and i < tilesWide and j >= 0 and j < tilesHigh

    method nodeAt( i:Int32, j:Int32 )->TrackNode
      if (i < 0 or i >= tilesWide or j < 0 or j >= tilesHigh) return null
      return nodes[i][j]

    method setNodeAt( i:Int32, j:Int32, node:TrackNode )
      nodes[i][j] = node

    method nodeLeftOf( i:Int32, j:Int32 )->TrackNode
      return nodeAt(i-1, j)

    method nodeAbove( i:Int32, j:Int32 )->TrackNode
      return nodeAt(i, j-1)

    method nodeRightOf( i:Int32, j:Int32 )->TrackNode
      return nodeAt(i+1, j)

    method nodeBelow( i:Int32, j:Int32 )->TrackNode
      return nodeAt(i, j+1)

    method hasEntranceLeftOf( i:Int32, j:Int32 )->Logical
      # does the node left of here exist, and if so, does it have an exit to it's right?
      return nodeLeftOf(i,j)? and TrackConnection.layoutContains(nodeLeftOf(i,j).exits, TrackConnection.RIGHT)

    method hasEntranceAbove( i:Int32, j:Int32 )->Logical
      # does the node above exist, and if so, does it have an below?
      return nodeAbove(i,j)? and TrackConnection.layoutContains(nodeAbove(i,j).exits, TrackConnection.BOTTOM)

    method hasEntranceRightOf( i:Int32, j:Int32 )->Logical
      # does the node right of here exist, and if so, does it have an exit to it's left?
      return nodeRightOf(i,j)? and TrackConnection.layoutContains(nodeRightOf(i,j).exits, TrackConnection.LEFT)

    method hasEntranceBelow( i:Int32, j:Int32 )->Logical
      # does the node below exist, and if so, does it have an exit above?
      return nodeBelow(i,j)? and TrackConnection.layoutContains(nodeBelow(i,j).exits, TrackConnection.TOP)

    method getEntranceLeftOf( i:Int32, j:Int32 )->TrackConnection
      return select{hasEntranceLeftOf(i,j):TrackConnection.LEFT || TrackConnection.NONE}

    method getEntranceAbove( i:Int32, j:Int32 )->TrackConnection
      return select{hasEntranceAbove(i,j):TrackConnection.TOP || TrackConnection.NONE}

    method getEntranceRightOf( i:Int32, j:Int32 )->TrackConnection
      return select{hasEntranceRightOf(i,j):TrackConnection.RIGHT || TrackConnection.NONE}

    method getEntranceBelow( i:Int32, j:Int32 )->TrackConnection
      return select{hasEntranceBelow(i,j):TrackConnection.BOTTOM || TrackConnection.NONE}

    method calcLayout( i:Int32, j:Int32 )->TrackTileInfo
      if (not contains(i,j)) return TrackTileInfo(i,j)
      local node = nodeAt(i,j)
      local exits = node.exits
      # bitwise-or together all the possible entrances
      local entrances = TrackConnection(
        getEntranceLeftOf(i,j) |
        getEntranceAbove(i,j) |
        getEntranceRightOf(i,j) |
        getEntranceBelow(i,j)
      )
      local combinedLayout = TrackConnection(exits->Int32 | entrances->Int32)
      return TrackTileInfo(i,j,node,combinedLayout,entrances,exits,node.activeExit)

    method calcLayout( ij:IJ )->TrackTileInfo
      return calcLayout(ij.i, ij.j)

    method to->String
      local rows = String[]
      forEach(j in 0..<tilesHigh)
        local topLines = String[]
        local bottomLines = String[]
        forEach(i in 0..<tilesWide)
          local nodeExits = nodeAt(i,j).exits
          local top =
            select{TrackConnection.layoutContains(nodeExits, TrackConnection.LEFT): "l" || " "} +
            select{TrackConnection.layoutContains(nodeExits, TrackConnection.TOP): "t" || " "}
          local bottom =
            select{TrackConnection.layoutContains(nodeExits, TrackConnection.BOTTOM): "b" || " "} +
            select{TrackConnection.layoutContains(nodeExits, TrackConnection.RIGHT): "r" || " "}
          topLines.add(top)
          bottomLines.add(bottom)
        endForEach
        rows.add("$\n$" (topLines.join('|'), bottomLines.join('|')))
      endForEach

      # two hyphens per tile, plus one hyphen per separator
      local separator = "\n$\n" ("-".times((tilesWide*2)+(tilesWide-1)))
      return rows.join(separator)

endClass